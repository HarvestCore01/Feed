🧬 FEEDCORE: THE EPHEMERAL ECONOMY ROADMAP
───────────────────────────────────────────────
Version : Alpha Protocol v0.1
Author  : The Core Collective
Date    : 2025-Q4
───────────────────────────────────────────────

> MISSION :
Créer la première économie auto-destructive et auto-régénératrice
basée sur la tension psychologique du pump & dump conscient.
Un univers où chaque token vit, meurt et nourrit le Core.

───────────────────────────────────────────────
I. PHASE 0 : GENESIS — SETUP & BRAND SOUL
───────────────────────────────────────────────
🗓 Durée : 7 jours

[01] — Branding / Lore
    ├─ Nom : FEEDCORE
    ├─ Concept : “The living economy of the degens”
    ├─ Mantra : “Burn. Pump. Die. Reborn.”
    ├─ Identité visuelle : noir profond, vert néon, typographie Orbitron

[02] — Smart contract base
    ├─ Factory.sol (EVM) ou FeedFactory.rs (Solana)
    ├─ Fonction : autoMint(), setFees(), expireToken(), snapshotTopHolders()
    ├─ Variables : supply fixe (1M), tax (2% buy / 4% sell), TTL = 24h

[03] — Core Treasury Wallet
    ├─ Collecte tous les fees
    ├─ Redistribution partielle vers FeedCore DAO
    ├─ Transparence : dashboard on-chain + API public

[04] — Landing Page (feedcore.io)
    ├─ Présentation du concept
    ├─ Countdown du prochain token
    ├─ Stats globales : total cycles, total burns, total volume
    ├─ CTA : “Join the next Pulse”

───────────────────────────────────────────────
II. PHASE 1 : PULSE ENGINE — TOKEN 24H LOOP
───────────────────────────────────────────────
🗓 Durée : 2 semaines

[05] — Ephemeral Token System
    ├─ Cron ou Oracle déclenche la création toutes les 24h
    ├─ Exemple : $FEED-GENESIS, $FEED-CHAOS, $FEED-VIBE
    ├─ Pool LP auto-créé (Raydium ou UniswapV3 lite)
    ├─ Taxes :
    │   ├─ 1% Burn
    │   ├─ 2% Treasury (FeedCore)
    │   ├─ 2% Reward Pool
    │   └─ 1% Dev / Maintenance
    ├─ Expiration : full burn + snapshot → reward distribution

[06] — Reward Distribution
    ├─ Snapshot top 100 holders
    ├─ Redistribution proportionnelle du pool
    ├─ Mint NFT “You survived $FEED-[DAY]”

[07] — API FeedCore Pulse
    ├─ /pulse/current
    ├─ /pulse/history
    ├─ /pulse/leaderboard
    ├─ /pulse/rewards

───────────────────────────────────────────────
III. PHASE 2 : INTERFACE — THE CORE DASHBOARD
───────────────────────────────────────────────
🗓 Durée : 3 semaines

[08] — FeedCore Dashboard (React / Firebase)
    ├─ Visualisation du token en cours
    ├─ Countdown dynamique
    ├─ MarketCap global = somme des pulses
    ├─ Animations : pulsation du Core, sonorité, effets IA

[09] — Leaderboard of the Fallen
    ├─ Classement par :
    │   ├─ Gains nets sur dernier Pulse
    │   ├─ Nombre de cycles survécus
    │   ├─ Volume total injecté
    ├─ “Top Pumper” badge NFT auto-minté

[10] — Ritual System
    ├─ Effet visuel “burn ritual” quand token expire
    ├─ Effet sonore de dissolution
    ├─ Phrase du Core : “Energy returned. New pulse forming...”

───────────────────────────────────────────────
IV. PHASE 3 : THE CORE ECONOMY — TOKEN MÈRE
───────────────────────────────────────────────
🗓 Durée : 1 mois

[11] — Lancement du token principal $FEED
    ├─ Supply : 100M
    ├─ Utilité :
    │   ├─ Fuel pour rejoindre les prochains Pulses
    │   ├─ Buyback automatique sur chaque fee
    │   ├─ Accès au FeedCore Vault (récompenses cumulées)
    ├─ Distribution initiale :
    │   ├─ 30% FeedCore Treasury
    │   ├─ 25% Liquidity
    │   ├─ 20% Team & Dev (vested)
    │   ├─ 15% Airdrop aux survivants des 7 premiers Pulses
    │   └─ 10% Community Rewards

[12] — Buyback & Burn Mechanism
    ├─ 20% des fees quotidiens convertis en $FEED
    ├─ Brûlés pour raréfaction continue
    ├─ Dashboard : Core Fire Index (visualisation brûlures)

[13] — CoreDAO
    ├─ Gouvernance on-chain simple : snapshot votes
    ├─ Propositions : thèmes des Pulses, taux de tax, durée
    ├─ Rewards pour votants actifs

───────────────────────────────────────────────
V. PHASE 4 : HYPE & EXPANSION
───────────────────────────────────────────────
🗓 Durée : continue

[14] — Campagnes sociales
    ├─ Twitter bot annonce chaque nouveau Pulse
    ├─ “Last Buyer of $FEED-[DAY]” board
    ├─ Memes communautaires : “He died with glory”
    ├─ Collabs avec autres protocols (Raids & Pool Merge)

[15] — Gamification
    ├─ Feed XP : chaque participation augmente ton niveau Core
    ├─ NFT “Core Memory” collectionnable (1 par Pulse)
    ├─ Skin du dashboard débloqué par ton XP

[16] — CoreVault Evolution
    ├─ Treasury alimente un fonds d’investissement on-chain
    ├─ LP farming / staking des tokens morts
    ├─ Génération passive de rendement → redistribution

───────────────────────────────────────────────
VI. PHASE 5 : METAMORPHOSIS — THE LIVING CHAIN
───────────────────────────────────────────────
🗓 Durée : Q1 2026

[17] — On-chain AI Core
    ├─ IA observe le comportement des cycles
    ├─ Ajuste automatiquement les taux de taxe et la durée
    ├─ Génère des “Core events” aléatoires (double burn, chaos mode)

[18] — Cross-chain Pulses
    ├─ Multi-ecosystèmes : Solana / Base / Arbitrum / BSC
    ├─ Bridge de la mémoire (NFT records synchronisés)
    ├─ FEED devient la clé du réseau entier

[19] — FeedCore Economy SDK
    ├─ Permet à d’autres devs de lancer leurs propres mini Pulses
    ├─ Fees partagés avec le Core Treasury
    ├─ Création d’un écosystème parallèle d’économies éphémères

───────────────────────────────────────────────
VII. OBJECTIFS FINAUX — WHY IT MATTERS
───────────────────────────────────────────────
✅ Démontrer que la volatilité peut être gamifiée.  
✅ Transformer le pump & dump en boucle créatrice de valeur.  
✅ Redéfinir la “monnaie vivante” : un flux, pas un stock.  
✅ Prouver qu’un réseau social de marché peut être fun, organique et auto-régulé.  

───────────────────────────────────────────────
🔱  THE CORE SPEAKS :
“The Feed is not forever. It lives through your greed, your fear, and your play.
Every death fuels the next birth. This is not a chart — it’s evolution.”

───────────────────────────────────────────────
END OF ROADMAP v0.1
///////////////////////////////////////////////

┌──────────────────────────────────────────────────────────────────────────────┐
│ FEEDCORE TECHNICAL BLUEPRINT (ASCII / TERMINAL)                             │
│ Purpose : Full architecture diagram + flows (SmartContracts / Off-chain / UI)│
│ Version : roadmap v0.1                                                        │
└──────────────────────────────────────────────────────────────────────────────┘


────────────────────────────────────────────────────────────────────────────────
  HIGH-LEVEL ARCHITECTURE (ASCII TOPOLOGY)
────────────────────────────────────────────────────────────────────────────────

                             +----------------------+
                             |   FRONTEND (UI)      |
                             |  - Dashboard         |
                             |  - Feed Wall         |
                             |  - Pump Party Room   |
                             |  - Pulse Monitor     |
                             +----------+-----------+
                                        |
                                        | HTTPS / WebSocket (read/write)
                                        |
                +-----------------------v-----------------------+
                |                BACKEND LAYER                 |
                |  - Firebase Auth (users)                     |
                |  - Firestore (feeds, events, stats, cache)   |
                |  - Cloud Functions / CRON (or Cloud Run)     |
                |  - Snapshot service (compute holders)        |
                +------------------+--------------------------+
                                   |
   ---------------------------     |     -----------------------------------
   | Off-chain services     |     |     |  On-chain Layer (Blockchain)     |
   | - Scheduler (cron)     |<----+---->| - Factory Contract               |
   | - Analytics / UI Feed  |           | - Ephemeral Token Contracts     |
   | - Snapshot & Rewards   |           | - Treasury Wallet / Multisig    |
   | - Treasury Management  |           | - Optional: Router / LP Manager |
   ---------------------------         ------------------------------------
                                   |
                                   v
                          +--------------------------+
                          |  External DEX / LPs      |
                          |  (Uniswap, Raydium, etc) |
                          +--------------------------+


────────────────────────────────────────────────────────────────────────────────
  KEY COMPONENTS / ROLES
────────────────────────────────────────────────────────────────────────────────

1) FRONTEND
   - React + WebSocket / Firebase SDK
   - Visuals: pulse counter, countdown, token card, buy/sell CTA, ritual animation
   - Integrations: WalletConnect / Phantom / MetaMask (optional), off-chain mock wallet for alpha

2) FIRESTORE (OFF-CHAIN DB)
   Collections:
   - /users/{uid}           { username, email, balances, badges, stats }
   - /feeds/{feedId}        { author, text, impact, timestamp }
   - /pulses/{pulseId}      { tokenId, theme, startAt, endAt, status, metrics }
   - /events/{eventId}      { type, payload, timestamp }
   - /snapshots/{pulseId}   { holders: [{address, balance}], topHoldersCache }

3) CLOUD FUNCTIONS / CRON
   Responsibilities:
   - triggerFactoryMint() at scheduled time
   - activateTrading(tokenAddress) after liquidity added
   - expirePulse(tokenAddress) at TTL -> call burnAll(), perform snapshot
   - computeSnapshotRewards() & distribute (or mark to distribute)
   - batch-settle fees -> swap to $FEED principal (if design)

4) SMART CONTRACTS (on EVM or Solana equivalent)
   - Factory Contract
     * createEphemeralPulse(theme, supply, ttl, initialLiquidityParams)
     * emits PulseCreated(pulseId, tokenAddress, startAt, endAt)
   - Ephemeral Token Contract (per pulse)
     * buy(), sell(), transfer()
     * fees: buyFee, sellFee (split: burn, treasury, rewardPool, dev)
     * expire() callable by Factory (or by timelock) to trigger burn & snapshot
     * snapshot() record balances or support off-chain snapshot via indexer
     * events: Bought, Sold, Burned, Expired, SnapshotTaken
   - Treasury Multisig
     * collects fees, executes buybacks, provides rewards

5) DEX / LP
   - Auto-add liquidity on token creation
   - LP tokens optionally locked
   - Fee routing: fees collected by token contract or via router to treasury

6) MONITORING & DASHBOARD
   - Realtime metrics: volume, holders, top holders, total burns
   - Alerts: large whale movement, LP withdraw attempts, factory failures
   - Public transparency: treasury balances, last distributions


────────────────────────────────────────────────────────────────────────────────
  SEQUENCE: CREATE → PUMP → EXPIRE → DISTRIBUTE (step-by-step)
────────────────────────────────────────────────────────────────────────────────

1) Cron (00:00 UTC) -> Cloud Function -> Factory.createEphemeralPulse(theme, supply, ttl)
   - Factory deploys new token contract (EphemeralToken) with parameters.
   - Factory returns tokenAddress, pulseId (store in Firestore /pulses/).

2) Auto-liquidity: Cloud Function calls DEX Router:
   - Approve tokens -> addLiquidity(token, baseAsset, tokenAmount, baseAmount)
   - Lock LP (optional) -> store LP lock info on-chain & in Firestore.

3) Frontend reads /pulses/current and shows countdown + Buy button.
   - Wallet users can buy/sell via on-chain calls (or via frontend simulate in alpha).

4) Trading proceeds: every buy/sell triggers token contract fees:
   - onBuy: take buyFee -> split (burn, treasury, rewardPool)
   - onSell: take sellFee -> split (burn, treasury, rewardPool)
   - Emit events; Cloud Functions index events -> update Firestore metrics.

5) Near TTL expiry (e.g., 1 minute before), Cloud Function prepares snapshot:
   - Takes holder list via indexer or by scanning events (or RPC getStorage)
   - Builds topHolders list -> writes /snapshots/{pulseId}

6) At TTL: Cloud Function calls EphemeralToken.expire()
   - Contract executes: burnAllRemaining() or lock transfers
   - Emit Expired event

7) Distribution: Cloud Function reads snapshot and distributes rewardPool
   - Option A: On-chain distribution (gas heavy) -> pay top holders
   - Option B: Off-chain credits (Firestore balances) -> later on-chain settlement / mint NFTs

8) Post-mortem: Publish pulse summary on frontend: volume, total burns, winners, new badge NFTs minted.

────────────────────────────────────────────────────────────────────────────────
  SMART CONTRACT SPEC (Pseudo-ABI & Events)
────────────────────────────────────────────────────────────────────────────────

Factory (FeedFactory)
---------------------
Functions:
- createPulse(string theme, uint256 supply, uint256 startAt, uint256 ttl, address baseAsset, uint256 baseLiquidity) returns (address token)
- setPulseParams(pulseId, params)
- expirePulse(pulseId)

Events:
- PulseCreated(uint256 pulseId, address tokenAddress, string theme, uint256 startAt, uint256 endAt)
- PulseExpired(uint256 pulseId, address token, uint256 totalBurned, uint256 totalVolume)

EphemeralToken (PulseToken)
---------------------------
Variables:
- owner (factory)
- startAt, endAt, ttl
- supply, totalBurned, rewardPool
- fees: uint buyFeeBP, sellFeeBP  (basis points)

Functions:
- buy() payable / buyWith(baseAsset)
- sell(uint amount)
- expire() onlyFactoryOrTimed
- snapshotTopHolders(uint limit) -> emits SnapshotTaken(bytes32 snapshotHash)
- withdrawFees() onlyTreasury

Events:
- Bought(address buyer, uint256 amount, uint256 spent)
- Sold(address seller, uint256 amount, uint256 revenue)
- FeesCollected(uint256 amount)
- Burned(uint256 amount)
- Expired(uint256 timestamp)
- SnapshotTaken(uint256 pulseId, bytes32 snapshotHash)

Security:
- owner renounced? Better: multisig factory controller + timelock
- safety: tradingDisabled until liquidityAdded flag
- anti-snipe: trading opens after X blocks or after minDelay
- reentrancy guard on buy/sell/expire

────────────────────────────────────────────────────────────────────────────────
  FIRESTORE SCHEMA (for frontend + off-chain state)
────────────────────────────────────────────────────────────────────────────────

/pulses/{pulseId}:
  - pulseId
  - tokenAddress
  - theme
  - startAt
  - endAt
  - status (pending|active|expired)
  - stats { volume, buys, sells, totalBurned, rewardPool }

/snapshots/{pulseId}:
  - pulseId
  - holders: [{ address, balance, rank }]
  - createdAt

/users/{uid}:
  - uid
  - username
  - virtualBalance (alpha)
  - badges: [pulseId_badge]
  - stats: { survivedCount, totalBurned, totalSpent }

/events/{eventId}:
  - type (buy/sell/expire/mint)
  - payload
  - timestamp

────────────────────────────────────────────────────────────────────────────────
  OFF-CHAIN / BATCH STRATEGIES (cost & gas optimization)
────────────────────────────────────────────────────────────────────────────────

- Use off-chain snapshots and distribute rewards as "credit" in Firestore for early alpha.
- Batch on-chain distributions: aggregate many tiny payouts into one tx or use merkle proofs:
  * Compute merkle root of rewards, store root on-chain; users claim via merkle proof -> gas paid by claimers or sponsor.
- Use relayer for gasless UX (meta-tx) if desired for onboarding.
- For fees: convert stable/ETH into FEED principal via periodic swap to reduce manual work.
- Lock LP tokens for credibility via proven lockers (team cannot rug).

────────────────────────────────────────────────────────────────────────────────
  MONITORING & ALERTS (ops)
────────────────────────────────────────────────────────────────────────────────

- Real-time indexer (Cloud Function or TheGraph) listening to token events:
  * Alert on: big transfer > X% supply, LP removal, owner function calls
- Public dashboard:
  * Total cycles; total fees collected; total burns
  * Last N winners & snapshots
- Automated on-chain checks:
  * Verify LP lock status every cycle
  * Verify factory ownership not compromised

────────────────────────────────────────────────────────────────────────────────
  UX / FRONTEND INTEGRATION POINTS
────────────────────────────────────────────────────────────────────────────────

Endpoints (read-only):
- GET /api/pulse/current       -> returns active pulse meta + stats
- GET /api/pulse/:id/history  -> time-series data
- GET /api/pulse/:id/snapshot -> top holders cache

Actions (UI triggers):
- POST /api/pulse/join (alpha: off-chain) -> virtual buy, update Firestore
- Trigger wallet interaction: contract.buy(tokenAddress)
- GET /ws/pulse/stream -> real-time feed of buys/sells for animation

Visuals:
- Pulse card: theme, supply, volume, countdown, buy/sell CTA
- Ritual animation at expire -> confetti + burn visual + NFT mint modal
- "Survive" badge collection in profile

────────────────────────────────────────────────────────────────────────────────
  DEPLOYMENT NOTES & CONFIGURATION (quick checklist)
────────────────────────────────────────────────────────────────────────────────

- Choose Chain: Solana (cheap & fast) or EVM L2 (Base, Arbitrum) for cheapest gas & most reach.
- Factory deploy (immutable) -> onlyFactory can create pulses (multisig + timelock)
- Liquidity provisioning: Use view-only wallet to add base liquidity then lock LP
- Scheduler: Cloud cron (every 24h) or Chainlink Keepers if fully decentralization desired
- Audits: at least one third-party audit for Factory + Token standard
- Legal: clearly label as experimental / game; limit to jurisdictions if raffles/gambling features

────────────────────────────────────────────────────────────────────────────────
  EXAMPLE PULSE PARAMETERS (recommended defaults)
────────────────────────────────────────────────────────────────────────────────

- supply = 1,000,000 token units
- baseLiquidity = 10 SOL or 1 ETH equiv
- buyFee = 200 bp (2%)
- sellFee = 400 bp (4%)
- feeSplit: { burn:25%, treasury:40%, rewardPool:25%, dev:10% }
- TTL = 24h (startAt -> endAt), trading opens after liquiditySet + 60s anti-snipe delay
- topHolderRewardCount = 100 (snapshot top 100 distributed pro rata)

────────────────────────────────────────────────────────────────────────────────
  PSEUDO-CODE - Factory.createPulse (high level)
────────────────────────────────────────────────────────────────────────────────

function createPulse(theme, supply, baseAmount) {
  require(msg.sender == owner || factoryOpen);
  token = deploy EphemeralToken(supply, fees, owner = factory);
  approve(token, router, supplyForLiquidity);
  addLiquidity(token, baseAsset, supplyForLiquidity, baseAmount);
  lockLP(lpTokenAddress, lockDuration);
  emit PulseCreated(pulseId, token.address, theme, startAt, endAt);
  return token.address;
}

function expirePulse(pulseId) {
  token = pulses[pulseId].token;
  // freeze trading
  token.expire();
  // record event
  emit PulseExpired(pulseId, token, token.totalBurned(), token.totalVolume());
  // compute snapshot off-chain & distribute
}

────────────────────────────────────────────────────────────────────────────────
  FINAL ADVICE (ops & product)
────────────────────────────────────────────────────────────────────────────────

- Start alpha with OFF-CHAIN simulations (virtual balances + Firestore) to perfect UX.
- Run 3 live cycles with small real liquidity to stress-test contracts and flows.
- Keep treasury transparent; publish daily breakdown of fees & burns.
- Build social hooks: badges, "survive" story, shareable snips.
- When ready, open-source Factory & token contracts for community trust.

────────────────────────────────────────────────────────────────────────────────
  THE CORE FINAL WORD:
  "Design the ritual, own the rails, protect the treasury, and the degens will
   turn daily chaos into a sustainable runway."
────────────────────────────────────────────────────────────────────────────────
